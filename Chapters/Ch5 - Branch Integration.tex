\chapter{Branch Integration}
\chapteroverlay
Whether you are working colaborativley with others and want to integrate thei work into whatever it is you are doing
or you have finished working on a feature for you project and now want to integrate it into the rest of what you've built
you will need to combine the two branches. You have two options when wanting to do this -- you can either \textit{merge} or 
\textit{rebase}. 
\newline\noindent Generally you will \textbf{merge} your branches together. This combines two branches by creating a merge commit
that ties their histories together. It preserves the true branching history. Any conflicts that may arrise are resolved at once.
\newline\noindent \textbf{Rebasing} on the other hand reapplies your branch's commits on top of another branch, rewriting history. 
It produces alinear history, as tough your work had always been based on that initial snapshot. Conflicts are handles one commit at a time.




\section{Merge}
To merge a hotfix branch back into your master branch to deploy to production. You do this with the git merge command:
\begin{gitBashBox}
checkout master
merge hotfix
\end{gitBashBox}
After resolving any merge-conflicts simply commit the changes (your editor will usually stage the changes). After a rebase you do \gitinline{rebase --continue}!

\subsection{What way does one merge using the base command?}
 All you have to do is check out the branch you wish to merge into and then run the \gitinline{git merge} command
 
\subsection{Two people working on one branch}
If p1 pushes changes to a remote, and p2 has local changes and also wants to push they need to merge first. They can do this with \gitinline{git pull}, however this leads to a messy history. Ideally p2 would run 
\begin{gitBashBox}
pull --rebase
\end{gitBashBox}
This ensures a clean history, and p2 can then push their changes to the remote. If they still have unstaged changes in their working directory, these must be stashed first.

\subsection{Merging a remote branch into local}
\begin{gitBashBox}
fetch origin <branch_name>
merge origin/<branch_name>
\end{gitBashBox}

\section{Undoing a merge}
\begin{enumerate}
    \item not commited: \gitinline{git merge --abort
}
    \item Commmited but not pushed \gitinline{git reset --hard HEAD~1
}
    \item pushed and commited \gitinline{git revert -m 1 <merge_commit_hash>}
\end{enumerate}

\section{Extracting a single subdirectory from a remote branch}
The sequence is an elegant way to "subtree split" a directory from an external source and incorporate it into another repository or branch, preserving a clean history for just that subdirectory.

\begin{gitBashBox}
fetch <remote>
switch --orphan fork_temp
rm -rf .
checkout <remote>/main -- path/to/subdirectory
mv path/to/subdirectory/* .
commit -m "Isolated <subdirectory_name> from <remote>"
switch your_branch
merge fork_temp --allow-unrelated-histories --no-commit --no-ff
add .
commit -m "Manually merged forked <subdirectory_name> directory" 
\end{gitBashBox}

\noindent\gitinline{git swithc --orphan <branch_name>} creates and switches to a new branch with no history. It's like starting a brand-new repo snapshot inside your existing repo.
\nln\gitinline{git rm -rf} removes all files from the working tree and staging area, just to be sure.
\nln\gitinline{git checkout <remote>/main -- path/to/subdirectory} checks out that directory from the <remote>'s remote branch. The - - tells Git “everything after this is a file/directory path.”
\nln\gitinline{git mv path/to/subdirectory/* .} moves all the checked-out files from that subdirectory into the root of the orphan branch.
\nln\gitinline{git merge fork_temp --allow-unrelated-histories} allows Git to combine two branches that do not share a common ancestor, which is necessary since fork\_temp was created without any history.

\section{Rebase}
Why would you do this though?
\begin{quote}
    Often, you'll do this to make sure your commits apply cleanly on a remote branch -- perhaps in a project to which you're trying to contribute but that you don't maintain.
\end{quote}

\begin{tcolorbox}[infoBox]
        \textcolor{red}{\textbf{NOTE}}: Do not rebase commits that exist outside your repository and that people may have based work on.
\end{tcolorbox}

Think of git rebase as lifting your commits off your current branch and then replaying them one by one on top of a new base (in our case, the updated main).

- main has new commits from person A.

- You are working on a feature branch that has commits of its own.

- Rebase takes your commits, temporarily removes them, updates your branch to look like main.

- Then tries to apply your commits on top, as if you branched off after person A's changes were already made.

This gives you a clean, linear history.\\

When you run \gitinline{git rebase main}, Git takes all your commits (from where your branch diverged from main) and replays them one by one on top of the updated main.

If Git tries applying a commit that touched a file that also changed in main, you get a conflict.

Once you fix it and \gitinline{git rebase --continue}, Git will move on to the next commit, and so on, until it finally reapplies your most recent work.

So:

You're not “losing” your latest changes — they just haven't been replayed yet.

You'll resolve conflicts in the order your commits were originally made.

At the end of the rebase, your branch will contain all your commits, sitting neatly on top of the updated main.

\begin{gitBashBox}
push --force-with-lease 
\end{gitBashBox}
must be used afterwards, because the new commit history is different than the one on the remote after rebasing.

\subsection{Rebasing up to a certain commit - step by step allowing for changes}
\begin{gitBashBox}
rebase -i <commit hash>    
\end{gitBashBox}

\begin{tcolorbox}[infoBox]
        \textcolor{red}{\textbf{NOTE}}: This is not to be confused with \gitinline{git pull --rebase}! Generally when you are working on a branch with someone else and they
have changes you need to pull, and your changes haven't been pushed yet, this is the way to go!
\end{tcolorbox}


